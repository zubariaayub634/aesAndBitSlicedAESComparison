package bitslicedAes;

import shared.SharedInformation;
import shared.Utility;

// A UNIVERSAL ASSUMPTION: all hex numbers in String are on two characters i.e between  and FF inclusive

public class BitslicedAES {

	Integer[][][] allRoundKeys;

	private Integer[][] addRoundKey(Integer[][] currentState, Integer[][] roundKey) {
		System.out.println("-> Adding Round Key: ");
		// TODO: implement
		return currentState;
	}

	private Integer[][] subBytes(Integer[][] currentState) {
		System.out.println("-> Substituting Bytes: ");
		// TODO: implement
		return currentState;
	}

	private Integer[][] shiftRows(Integer[][] currentState) {
		System.out.println("-> Shifting Rows: ");
		// TODO: implement
		return currentState;
	}

	private Integer[][] mixColumns(Integer[][] currentState) {
		System.out.println("-> Mixing Columns: ");
		// TODO: implement
		return currentState; // TODO: implement
	}

	private Integer[][] performInitialRound(Integer[][] currentState) {
		System.out.println("\nINITIAL ROUND:");
		// TODO: implement
		return currentState;
	}

	private Integer[][] performMainRound(Integer[][] currentState, Integer roundNo) {
		System.out.println("\nMAIN ROUND " + roundNo.toString() + ":");
		// TODO: implement
		return currentState;
	}

	private Integer[][] performFinalRound(Integer[][] currentState) {
		System.out.println("\nFINAL ROUND:");
		// TODO: implement
		return currentState;
	}

	private Integer[][] transformBundle(Integer[][] currentState) {
		System.out.println("-> Transforming Bundle for Bitslicing: ");
		// TODO: implement
		Integer[][] newState = new Integer[SharedInformation.n * 2][SharedInformation.n / 2];
		int currentStateRow = 0;
		for (int i = SharedInformation.n / 2 - 1; i >= 0; i--) // column of newState being accessed
		{
			int j = 0; // row of newState being accessed
			// even index row of currentState being accessed
			for (int k = SharedInformation.n - 1; k >= 0; k--) {
				newState[j][i] = currentState[currentStateRow][k];
				j++;
			}

			currentStateRow++;

			// odd index row of currentState being accessed
			for (int k = SharedInformation.n - 1; k >= 0; k--) {
				newState[j][i] = currentState[currentStateRow][k];
				j++;
			}

			currentStateRow++;
		}
		return newState;
	}

	private Integer[][] encrypt(Integer[][] state, Integer[][] cipherKey) {
		System.out.println("\nGENERATING ALL ROUND KEYS...");
		allRoundKeys = SharedInformation.generateAllRoundKeys(cipherKey);
		Integer[][] temp = transformBundle(state);
		Utility.printArray(temp);
		// TODO: implement
		return state;
	}

	public static void main(String[] args) {
		Integer[][] plainText = {
				{ 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20 },
				{ 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54 },
				{ 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77 },
				{ 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f },
				{ 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20 },
				{ 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54 },
				{ 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77 },
				{ 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f },
				{ 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20 },
				{ 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54 },
				{ 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77 },
				{ 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f },
				{ 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20 },
				{ 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54 },
				{ 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77 },
				{ 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f } };
		Integer[][] key = {
				{ 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67 },
				{ 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20 },
				{ 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46 },
				{ 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75 },
				{ 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67 },
				{ 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20 },
				{ 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46 },
				{ 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75 },
				{ 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67 },
				{ 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20 },
				{ 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46 },
				{ 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75 },
				{ 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67 },
				{ 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20 },
				{ 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46 },
				{ 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75 } };
		BitslicedAES bitslicedAes = new BitslicedAES();
		Utility.printArray(plainText);
		System.out.println();
		Integer[][] cipherText = bitslicedAes.encrypt(plainText, key);
		System.out.println("\nCIPHER TEXT:");
		Utility.printArray(cipherText);
	}
}
