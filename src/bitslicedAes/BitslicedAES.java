package bitslicedAes;

import shared.SharedInformation;
import shared.Utility;

// A UNIVERSAL ASSUMPTION: all hex numbers in String are on two characters i.e between  and FF inclusive

public class BitslicedAES {

	Integer[][][] allRoundKeys;

	private Integer[][] addRoundKey(Integer[][] currentState, Integer[][] roundKey) {
		System.out.println("-> Adding Round Key: ");
		// TODO: implement
		return currentState;
	}

	private Integer[][] subBytes(Integer[][] currentState) {
		System.out.println("-> Substituting Bytes: ");
		// TODO: implement
		return currentState;
	}

	private Integer[][] shiftRows(Integer[][] currentState) {
		System.out.println("-> Shifting Rows: ");
		// TODO: implement
		return currentState;
	}

	private Integer[][] mixColumns(Integer[][] currentState) {
		System.out.println("-> Mixing Columns: ");
		// TODO: implement
		return currentState; // TODO: implement
	}

	private Integer[][] performInitialRound(Integer[][] currentState) {
		System.out.println("\nINITIAL ROUND:");
		// TODO: implement
		return currentState;
	}

	private Integer[][] performMainRound(Integer[][] currentState, Integer roundNo) {
		System.out.println("\nMAIN ROUND " + roundNo.toString() + ":");
		// TODO: implement
		return currentState;
	}

	private Integer[][] performFinalRound(Integer[][] currentState) {
		System.out.println("\nFINAL ROUND:");
		// TODO: implement
		return currentState;
	}

	public Integer[][] encrypt(Integer[][] state, Integer[][] cipherKey) {
		BundleTransformThread[] allTransformThreads = new BundleTransformThread[SharedInformation.aesRounds + 2];
		int stateTransformThreadIndex = SharedInformation.aesRounds + 1;
		allTransformThreads[stateTransformThreadIndex] = new BundleTransformThread(state);
		System.out.println("\nGENERATING ALL ROUND KEYS...");
		allRoundKeys = SharedInformation.generateAllRoundKeys(cipherKey);
		for (int i = 0; i < allRoundKeys.length; i++) {
			allTransformThreads[i] = new BundleTransformThread(allRoundKeys[i]);
		}
		while (!allTransformThreads[stateTransformThreadIndex].transformComplete)
			;

		// Integer[][] temp = transformBundle(state);
		// Utility.printArray(temp);
		// TODO: implement
		return state;
	}

	public static void main(String[] args) {
		Integer[][] plainText = {
				{ 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20 },
				{ 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54 },
				{ 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77 },
				{ 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f },
				{ 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20 },
				{ 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54 },
				{ 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77 },
				{ 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f },
				{ 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20 },
				{ 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54 },
				{ 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77 },
				{ 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f },
				{ 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20, 0x54, 0x4f, 0x4e, 0x20 },
				{ 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54, 0x77, 0x6e, 0x69, 0x54 },
				{ 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77, 0x6F, 0x65, 0x6e, 0x77 },
				{ 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f, 0x20, 0x20, 0x65, 0x6f } };
		Integer[][] key = {
				{ 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67 },
				{ 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20 },
				{ 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46 },
				{ 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75 },
				{ 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67 },
				{ 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20 },
				{ 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46 },
				{ 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75 },
				{ 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67 },
				{ 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20 },
				{ 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46 },
				{ 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75 },
				{ 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67, 0x54, 0x73, 0x20, 0x67 },
				{ 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20, 0x68, 0x20, 0x4b, 0x20 },
				{ 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46, 0x61, 0x6d, 0x75, 0x46 },
				{ 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75, 0x74, 0x79, 0x6e, 0x75 } };
		BitslicedAES bitslicedAes = new BitslicedAES();
		Utility.printArray(plainText);
		System.out.println();
		Integer[][] cipherText = bitslicedAes.encrypt(plainText, key);
		System.out.println("\nCIPHER TEXT:");
		Utility.printArray(cipherText);
	}
}
